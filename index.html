<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebase Hamz Tool</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        :root {
            --bg-dark: #0f172a;
            --text-light: #f1f5f9;
            --neon-red: #ff2d55;
            --neon-red-dark: #e02444;
            --gray: #475569;
            --glow: rgba(255, 45, 85, 0.4);
            --console-bg: #1e293b;
            --log-bg: #2d3748;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-light);
            min-height: 100vh;
            font-size: 16px;
            line-height: 1.5;
            overflow-x: hidden;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 32px;
            display: flex;
            flex-direction: column;
            gap: 32px;
        }
        .header {
            position: sticky;
            top: 0;
            background-color: var(--bg-dark);
            padding: 16px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid var(--gray);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            animation: slideInDown 0.5s ease-in;
        }
        .header i {
            font-size: 1.8rem;
            color: var(--neon-red);
            transition: transform 0.3s;
        }
        .header i:hover {
            transform: scale(1.2);
        }
        .header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--neon-red);
            text-shadow: 0 0 8px var(--glow);
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 32px;
            width: 100%;
            padding-right: 16px;
            box-sizing: border-box;
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }
        .section {
            background-color: var(--console-bg);
            padding: 24px;
            border-radius: 10px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            animation: fadeInUp 0.6s ease-in;
            transition: transform 0.3s, box-shadow 0.3s;
        }
        .section:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.4);
        }
        .section h2 {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--neon-red);
            margin-bottom: 16px;
            text-transform: uppercase;
            text-shadow: 0 0 4px var(--glow);
        }
        .input-field {
            background-color: var(--log-bg);
            border: 1px solid var(--gray);
            border-radius: 6px;
            padding: 12px;
            color: var(--text-light);
            font-size: 0.95rem;
            width: 100%;
            margin-bottom: 12px;
            transition: all 0.3s ease;
        }
        .input-field:focus {
            outline: none;
            border-color: var(--neon-red);
            box-shadow: 0 0 6px var(--glow);
            transform: scale(1.01);
        }
        .btn {
            background-color: var(--neon-red);
            color: var(--text-light);
            padding: 12px;
            border-radius: 6px;
            border: none;
            font-size: 0.95rem;
            font-weight: 600;
            width: 100%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        .btn:hover {
            background-color: var(--neon-red-dark);
            transform: scale(1.03);
            box-shadow: 0 0 10px var(--glow);
        }
        .btn:active {
            transform: scale(0.97);
        }
        .btn.disabled {
            background-color: var(--gray);
            cursor: not-allowed;
            box-shadow: none;
        }
        .btn .ripple {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            transform: scale(0);
            animation: ripple 0.5s linear;
        }
        @keyframes ripple {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
        .output-bar {
            background-color: var(--bg-dark);
            padding: 10px 16px;
            border-top: 1px solid var(--gray);
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 99;
        }
        .output-container {
            background-color: var(--bg-dark);
            padding: 0;
            border-top: none;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.6s ease-in-out, padding 0.3s ease-in-out;
            z-index: 98;
        }
        .output-container.visible {
            max-height: 300px;
            padding: 20px;
            border-top: 1px solid var(--gray);
        }
        .output {
            background-color: var(--console-bg);
            border: 1px solid var(--neon-red);
            border-radius: 8px;
            padding: 16px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 260px;
            overflow-y: auto;
            white-space: pre-wrap;
            transition: all 0.3s ease;
        }
        .output p {
            background-color: var(--log-bg);
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            animation: slideInLeft 0.3s ease-in;
        }
        .output p .timestamp {
            color: #94a3b8;
            margin-right: 8px;
        }
        .toggle-output-btn {
            background-color: var(--neon-red);
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }
        .toggle-output-btn:hover {
            background-color: var(--neon-red-dark);
            transform: scale(1.05);
            box-shadow: 0 0 10px var(--glow);
        }
        .warning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background-color: #7f1d1d;
            color: var(--text-light);
            padding: 20px;
            border-radius: 10px;
            font-size: 0.9rem;
            text-align: center;
            border: 1px solid var(--neon-red);
            box-shadow: 0 0 12px var(--glow);
            z-index: 999;
            max-width: 90%;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .warning.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
        }
        .warning button {
            background-color: var(--neon-red);
            color: var(--text-light);
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            margin-top: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .warning button:hover {
            background-color: var(--neon-red-dark);
            transform: scale(1.05);
        }
        .toast {
            position: fixed;
            top: 24px;
            right: 24px;
            background-color: var(--console-bg);
            color: var(--text-light);
            padding: 12px 20px;
            border-radius: 6px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transform: translateY(-100px);
            opacity: 0;
            transition: all 0.5s ease;
        }
        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideInDown {
            from { opacity: 0; transform: translateY(-15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes slideInLeft {
            from { opacity: 0; transform: translateX(-15px); }
            to { opacity: 1; transform: translateX(0); }
        }
        .loading::after {
            content: '';
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--text-light);
            border-radius: 50%;
            border-top-color: var(--neon-red);
            animation: spin 1s linear infinite;
            margin-left: 8px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        @media (max-width: 768px) {
            .grid-container {
                grid-template-columns: 1fr;
                padding-right: 8px;
                max-height: calc(100vh - 150px);
            }
            .container {
                padding: 16px;
            }
            .header h1, .header i {
                font-size: 1.5rem;
            }
            .section h2 {
                font-size: 1.1rem;
            }
            .input-field, .btn {
                font-size: 0.9rem;
                padding: 10px;
            }
            .output {
                max-height: 200px;
                font-size: 0.85rem;
            }
            .output p {
                padding: 6px 10px;
            }
            .toggle-output-btn {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <i class="fas fa-fire"></i>
            <h1>Firebase Hamz Tool</h1>
        </div>

        <div class="warning" id="httpsWarning">
            Running locally (file://). Firebase requires HTTPS. Use a local server (e.g., Live Server) or host on HTTPS.
            <button onclick="hideWarning()">OK</button>
        </div>

        <div class="toast" id="toast">
            <p id="toastMessage"></p>
        </div>

        <div class="grid-container">
            <div class="section">
                <h2>Apply URL & Path</h2>
                <input type="url" id="databaseUrl" class="input-field" placeholder="Enter Firebase Database URL" aria-label="Firebase Database URL">
                <input type="text" id="databasePath" class="input-field" placeholder="Enter Database Path (e.g., / or /users)" value="/" aria-label="Database Path">
                <button id="applyUrlBtn" class="btn" onclick="applyUrl()" aria-label="Apply Firebase URL and Path">
                    <i class="fas fa-check"></i> Apply URL & Path
                </button>
            </div>

            <div class="section">
                <h2>Create Data</h2>
                <input type="number" id="assetCount" min="1" max="1000" value="1" class="input-field" placeholder="Number of Items" aria-label="Number of Items">
                <select id="assetType" class="input-field" aria-label="Item Type">
                    <option value="all">All</option>
                    <option value="folder">Folder</option>
                    <option value="boolean">Boolean</option>
                    <option value="string">String</option>
                    <option value="number">Number</option>
                </select>
                <button id="spamAssetsBtn" class="btn" onclick="spamAssets()" aria-label="Create Data">
                    <i class="fas fa-plus"></i> Create
                </button>
            </div>

            <div class="section">
                <h2>Rename All Data</h2>
                <input type="text" id="renamePrefix" class="input-field" placeholder="Enter custom prefix (e.g., CustomPrefix)" aria-label="Custom Rename Prefix">
                <button id="renameAssetsBtn" class="btn" onclick="renameAssets()" aria-label="Rename All Data">
                    <i class="fas fa-edit"></i> Rename
                </button>
            </div>

            <div class="section">
                <h2>Delete Data</h2>
                <input type="text" id="deletePath" class="input-field" placeholder="Enter path to delete (e.g., / or /users)" value="/" aria-label="Delete Path">
                <button id="deleteAssetsBtn" class="btn" onclick="deleteDirectories()" aria-label="Delete Data">
                    <i class="fas fa-trash"></i> Delete
                </button>
            </div>

            <div class="section">
                <h2>Fetch Database</h2>
                <button id="fetchDatabaseBtn" class="btn" onclick="fetchDatabase()" aria-label="Fetch Database">
                    <i class="fas fa-database"></i> Fetch Data
                </button>
            </div>

            <div class="section">
                <h2>Flood Database</h2>
                <input type="number" id="floodCount" min="1" max="10000" value="1000" class="input-field" placeholder="Number of Items to Flood" aria-label="Number of Items to Flood">
                <button id="floodDatabaseBtn" class="btn" onclick="floodDatabase()" aria-label="Flood Database">
                    <i class="fas fa-bolt"></i> Flood
                </button>
            </div>

            <div class="section">
                <h2>Corrupt Data</h2>
                <button id="corruptDataBtn" class="btn" onclick="corruptData()" aria-label="Corrupt Data">
                    <i class="fas fa-bug"></i> Corrupt
                </button>
            </div>

            <div class="section">
                <h2>Backup Database</h2>
                <button id="backupDatabaseBtn" class="btn" onclick="backupDatabase()" aria-label="Backup Database">
                    <i class="fas fa-download"></i> Backup
                </button>
            </div>

            <div class="section">
                <h2>Restore Database</h2>
                <input type="file" id="restoreFile" class="input-field" accept=".json" aria-label="Restore Database File">
                <button id="restoreDatabaseBtn" class="btn" onclick="restoreDatabase()" aria-label="Restore Database">
                    <i class="fas fa-upload"></i> Restore
                </button>
            </div>

            <div class="section">
                <h2>Clear Output</h2>
                <button id="clearOutputBtn" class="btn" onclick="clearOutput()" aria-label="Clear Output">
                    <i class="fas fa-eraser"></i> Clear
                </button>
            </div>

            <div class="section">
                <h2>Analyze Database</h2>
                <button id="analyzeDatabaseBtn" class="btn" onclick="analyzeDatabase()" aria-label="Analyze Database">
                    <i class="fas fa-chart-bar"></i> Analyze
                </button>
            </div>
        </div>

        <div class="output-bar">
            <button class="toggle-output-btn" onclick="toggleOutput()" aria-label="Toggle Console Output">
                <i class="fas fa-eye"></i> <span id="toggleOutputText">Show Output</span>
            </button>
        </div>
        <div class="output-container" id="outputContainer">
            <div class="output" id="output" role="log" aria-live="polite"></div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.14.1/firebase-database-compat.js"></script>

    <script>
        let database = null;
        let currentPath = '/';
        const outputDiv = document.getElementById('output');
        const outputContainer = document.getElementById('outputContainer');
        const toggleOutputText = document.getElementById('toggleOutputText');
        const httpsWarning = document.getElementById('httpsWarning');
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toastMessage');
        const buttons = {
            applyUrl: document.getElementById('applyUrlBtn'),
            spamAssets: document.getElementById('spamAssetsBtn'),
            renameAssets: document.getElementById('renameAssetsBtn'),
            deleteAssets: document.getElementById('deleteAssetsBtn'),
            fetchDatabase: document.getElementById('fetchDatabaseBtn'),
            floodDatabase: document.getElementById('floodDatabaseBtn'),
            corruptData: document.getElementById('corruptDataBtn'),
            backupDatabase: document.getElementById('backupDatabaseBtn'),
            restoreDatabase: document.getElementById('restoreDatabaseBtn'),
            clearOutput: document.getElementById('clearOutputBtn'),
            analyzeDatabase: document.getElementById('analyzeDatabaseBtn')
        };

        function toggleOutput() {
            outputContainer.classList.toggle('visible');
            toggleOutputText.textContent = outputContainer.classList.contains('visible') ? 'Hide Output' : 'Show Output';
        }

        if (window.location.protocol === 'file:') {
            httpsWarning.classList.add('show');
        }

        function hideWarning() {
            httpsWarning.classList.remove('show');
        }

        function showToast(message) {
            toastMessage.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        function displayMessage(message) {
            const timestamp = new Date().toLocaleTimeString();
            const messageDiv = document.createElement('p');
            messageDiv.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
            outputDiv.appendChild(messageDiv);
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        function clearOutput() {
            outputDiv.innerHTML = '';
            showToast('Output cleared.');
            displayMessage('Output cleared.');
        }

        function setLoading(button, isLoading) {
            button.disabled = isLoading;
            button.classList.toggle('loading', isLoading);
        }

        document.querySelectorAll('.btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                const ripple = document.createElement('span');
                ripple.classList.add('ripple');
                const rect = btn.getBoundingClientRect();
                const size = Math.max(rect.width, rect.height);
                ripple.style.width = ripple.style.height = `${size}px`;
                ripple.style.left = `${e.clientX - rect.left - size / 2}px`;
                ripple.style.top = `${e.clientY - rect.top - size / 2}px`;
                btn.appendChild(ripple);
                setTimeout(() => ripple.remove(), 500);
            });
        });

        let debounceTimeout;
        async function applyUrl() {
            clearTimeout(debounceTimeout);
            setLoading(buttons.applyUrl, true);
            debounceTimeout = setTimeout(async () => {
                const databaseUrl = document.getElementById('databaseUrl').value.trim();
                const pathInput = document.getElementById('databasePath').value.trim();
                if (!databaseUrl || !databaseUrl.startsWith('https://')) {
                    showToast('Invalid Firebase URL! Must start with https://');
                    setLoading(buttons.applyUrl, false);
                    return;
                }
                try {
                    const firebaseConfig = { databaseURL: databaseUrl };
                    firebase.initializeApp(firebaseConfig);
                    database = firebase.database();
                    currentPath = pathInput || '/';
                    showToast(`Firebase URL and path (${currentPath}) applied successfully.`);
                    displayMessage(`Firebase URL and path (${currentPath}) applied successfully.`);
                } catch (error) {
                    showToast(`Failed to initialize Firebase: ${error.message}`);
                    displayMessage(`Failed to initialize Firebase: ${error.message}`);
                    console.error('Firebase Error:', error);
                } finally {
                    setLoading(buttons.applyUrl, false);
                }
            }, 500);
        }

        async function spamAssets() {
            if (!database) {
                showToast('Please apply Firebase URL and path first!');
                return;
            }
            setLoading(buttons.spamAssets, true);
            const count = parseInt(document.getElementById('assetCount').value);
            const type = document.getElementById('assetType').value;
            if (!count || count < 1 || count > 1000) {
                showToast('Enter a valid number of items (1-1000)!');
                setLoading(buttons.spamAssets, false);
                return;
            }
            displayMessage(`Creating ${count} ${type} items recursively at path ${currentPath}...`);
            try {
                const types = type === 'all' ? ['folder', 'boolean', 'string', 'number'] : [type];
                const updates = {};
                async function processPath(path) {
                    const snapshot = await database.ref(path).once('value');
                    const data = snapshot.val() || {};
                    Object.keys(data).forEach(key => {
                        if (typeof data[key] === 'object' && data[key] !== null && !Array.isArray(data[key])) {
                            processPath(`${path === '/' ? '' : path}/${key}`);
                        }
                    });
                    for (const t of types) {
                        for (let i = 0; i < count; i++) {
                            const itemKey = `item_${t}_${Date.now()}_${i}`;
                            let value;
                            switch (t) {
                                case 'folder':
                                    value = { name: '@Hamzzzt Is Here!', created: Date.now() };
                                    break;
                                case 'boolean':
                                    value = true;
                                    break;
                                case 'string':
                                    value = '@Hamzzzt Is Here!';
                                    break;
                                case 'number':
                                    value = 42;
                                    break;
                            }
                            updates[`${path === '/' ? '' : path}/${itemKey}`] = value;
                        }
                    }
                }
                await processPath(currentPath);
                await database.ref().update(updates);
                showToast(`Successfully created ${count * types.length} items recursively.`);
                displayMessage(`Successfully created ${count * types.length} items recursively at path ${currentPath}.`);
            } catch (error) {
                showToast(`Failed to create items: ${error.message}`);
                displayMessage(`Failed to create items: ${error.message}`);
                console.error('Create Data Error:', error);
            } finally {
                setLoading(buttons.spamAssets, false);
            }
        }

        function sanitizePrefix(prefix) {
            return prefix.replace(/[^a-zA-Z0-9_-]/g, '') || 'CustomPrefix';
        }

        async function renameAssets() {
            if (!database) {
                showToast('Please apply Firebase URL and path first!');
                return;
            }
            setLoading(buttons.renameAssets, true);
            const customPrefix = sanitizePrefix(document.getElementById('renamePrefix').value.trim());
            displayMessage(`Renaming all data and converting all values to strings recursively at path ${currentPath}...`);
            try {
                const snapshot = await database.ref(currentPath).once('value');
                const data = snapshot.val();
                if (!data) {
                    showToast('No data found to rename.');
                    displayMessage(`No data found at path ${currentPath} to rename.`);
                    setLoading(buttons.renameAssets, false);
                    return;
                }
                const deletions = {};
                const additions = {};
                let index = 0;
                const BATCH_SIZE = 100;
                function processNode(node, parentPath) {
                    if (!node || typeof node !== 'object') {
                        displayMessage(`Skipping invalid node at ${parentPath}`);
                        return;
                    }
                    Object.keys(node).forEach(key => {
                        try {
                            const newKey = `${customPrefix}_${index++}_${Date.now()}`;
                            const fullPath = parentPath ? `${parentPath}/${key}` : key;
                            const newFullPath = parentPath ? `${parentPath}/${newKey}` : newKey;
                            deletions[fullPath] = null;
                            additions[newFullPath] = 'Renamed_@Hamzzzt';
                        } catch (error) {
                            displayMessage(`Error processing node at ${parentPath}/${key}: ${error.message}`);
                        }
                    });
                }
                processNode(data, currentPath === '/' ? '' : currentPath);
                let deletionKeys = Object.keys(deletions);
                for (let i = 0; i < deletionKeys.length; i += BATCH_SIZE) {
                    const batch = {};
                    for (let j = i; j < Math.min(i + BATCH_SIZE, deletionKeys.length); j++) {
                        batch[deletionKeys[j]] = deletions[deletionKeys[j]];
                    }
                    try {
                        await database.ref().update(batch);
                        displayMessage(`Processed deletion batch ${Math.floor(i / BATCH_SIZE) + 1} of ${Math.ceil(deletionKeys.length / BATCH_SIZE)}`);
                    } catch (error) {
                        showToast(`Failed to apply deletion batch: ${error.message}`);
                        displayMessage(`Failed to apply deletion batch: ${error.message}`);
                        if (error.code === 'PERMISSION_DENIED') {
                            displayMessage('Permission denied. Ensure your Firebase rules allow write access.');
                        }
                        throw error;
                    }
                }
                let additionKeys = Object.keys(additions);
                for (let i = 0; i < additionKeys.length; i += BATCH_SIZE) {
                    const batch = {};
                    for (let j = i; j < Math.min(i + BATCH_SIZE, additionKeys.length); j++) {
                        batch[additionKeys[j]] = additions[additionKeys[j]];
                    }
                    try {
                        await database.ref().update(batch);
                        displayMessage(`Processed addition batch ${Math.floor(i / BATCH_SIZE) + 1} of ${Math.ceil(additionKeys.length / BATCH_SIZE)}`);
                    } catch (error) {
                        showToast(`Failed to apply addition batch: ${error.message}`);
                        displayMessage(`Failed to apply addition batch: ${error.message}`);
                        if (error.code === 'PERMISSION_DENIED') {
                            displayMessage('Permission denied. Ensure your Firebase rules allow write access.');
                        }
                        throw error;
                    }
                }
                showToast('Successfully renamed all data and converted values to strings.');
                displayMessage(`Successfully renamed all data and converted values to strings at path ${currentPath}.`);
            } catch (error) {
                showToast(`Failed to rename data: ${error.message}`);
                displayMessage(`Failed to rename data: ${error.message}`);
                if (error.code === 'PERMISSION_DENIED') {
                    displayMessage('Permission denied. Ensure your Firebase rules allow write access.');
                }
                console.error('Rename Data Error:', error);
            } finally {
                setLoading(buttons.renameAssets, false);
            }
        }

        async function deleteDirectories() {
            if (!database) {
                showToast('Please apply Firebase URL first!');
                return;
            }
            const deletePath = document.getElementById('deletePath').value.trim() || '/';
            if (!confirm(`Are you sure you want to delete ALL folders and strings at path ${deletePath}? This cannot be undone.`)) {
                return;
            }
            setLoading(buttons.deleteAssets, true);
            displayMessage(`Inspecting folders and strings at path ${deletePath} for deletion...`);
            try {
                const snapshot = await database.ref(deletePath).once('value');
                const data = snapshot.val();
                if (!data) {
                    showToast('No data found to delete.');
                    displayMessage(`No data found at path ${deletePath}.`);
                    setLoading(buttons.deleteAssets, false);
                    return;
                }
                const updates = {};
                const targetedNodes = [];
                function processNode(node, parentPath) {
                    if (!node || typeof node !== 'object') return;
                    Object.keys(node).forEach(key => {
                        const fullPath = parentPath ? `${parentPath}/${key}` : key;
                        if (typeof node[key] === 'string') {
                            updates[fullPath] = null;
                            targetedNodes.push(`String: ${fullPath}`);
                        } else if (typeof node[key] === 'object' && node[key] !== null && !Array.isArray(node[key]) && node[key].name) {
                            updates[fullPath] = null;
                            targetedNodes.push(`Folder: ${fullPath}`);
                        } else if (typeof node[key] === 'object' && node[key] !== null && !Array.isArray(node[key])) {
                            processNode(node[key], fullPath);
                        }
                    });
                }
                processNode(data, deletePath === '/' ? '' : deletePath);
                if (targetedNodes.length === 0) {
                    showToast('No folders or strings found to delete.');
                    displayMessage(`No folders or strings found to delete at path ${deletePath}.`);
                    setLoading(buttons.deleteAssets, false);
                    return;
                }
                displayMessage(`Targeted for deletion:\n${targetedNodes.join('\n')}`);
                await database.ref().update(updates);
                const verifySnapshot = await database.ref(deletePath).once('value');
                const remainingData = verifySnapshot.val();
                if (remainingData) {
                    const remainingKeys = Object.keys(remainingData).join(', ');
                    showToast('Some non-folder/string data remains after deletion.');
                    displayMessage(`Deletion complete at ${deletePath}. Non-folder/string data remains: ${remainingKeys}`);
                } else {
                    showToast(`Successfully deleted all folders and strings at ${deletePath}.`);
                    displayMessage(`Successfully deleted all folders and strings at ${deletePath}. No data remains.`);
                }
            } catch (error) {
                showToast(`Failed to delete data: ${error.message}`);
                displayMessage(`Failed to delete data at ${deletePath}: ${error.message}`);
                if (error.code === 'PERMISSION_DENIED') {
                    displayMessage('Permission denied. Ensure your Firebase rules allow write access.');
                }
                console.error('Delete Data Error:', error);
            } finally {
                setLoading(buttons.deleteAssets, false);
            }
        }

        async function fetchDatabase() {
            if (!database) {
                showToast('Please apply Firebase URL and path first!');
                return;
            }
            setLoading(buttons.fetchDatabase, true);
            displayMessage(`Fetching database data recursively from path ${currentPath}...`);
            try {
                const snapshot = await database.ref(currentPath).once('value');
                const data = snapshot.val();
                if (!data) {
                    showToast('No data found.');
                    displayMessage(`No data found at path ${currentPath}.`);
                    setLoading(buttons.fetchDatabase, false);
                    return;
                }
                const formattedData = JSON.stringify(data, null, 2);
                showToast('Database data fetched successfully.');
                displayMessage(`Database Data from ${currentPath}:\n${formattedData}`);
            } catch (error) {
                showToast(`Failed to fetch data: ${error.message}`);
                displayMessage(`Failed to fetch data: ${error.message}`);
                console.error('Fetch Database Error:', error);
            } finally {
                setLoading(buttons.fetchDatabase, false);
            }
        }

        async function floodDatabase() {
            if (!database) {
                showToast('Please apply Firebase URL and path first!');
                return;
            }
            setLoading(buttons.floodDatabase, true);
            const count = parseInt(document.getElementById('floodCount').value);
            if (!count || count < 1 || count > 10000) {
                showToast('Enter a valid number of items (1-10000)!');
                setLoading(buttons.floodDatabase, false);
                return;
            }
            displayMessage(`Flooding database with ${count} items recursively at path ${currentPath}...`);
            try {
                const updates = {};
                async function processPath(path) {
                    const snapshot = await database.ref(path).once('value');
                    const data = snapshot.val() || {};
                    Object.keys(data).forEach(key => {
                        if (typeof data[key] === 'object' && data[key] !== null && !Array.isArray(data[key])) {
                            processPath(`${path === '/' ? '' : path}/${key}`);
                        }
                    });
                    for (let i = 0; i < count; i++) {
                        const itemKey = `flood_${Date.now()}_${i}`;
                        updates[`${path === '/' ? '' : path}/${itemKey}`] = {
                            name: `Flood Item ${i}`,
                            created: Date.now(),
                            value: Math.random()
                        };
                    }
                }
                await processPath(currentPath);
                await database.ref().update(updates);
                showToast(`Successfully flooded database with ${count} items recursively.`);
                displayMessage(`Successfully flooded database with ${count} items recursively at path ${currentPath}.`);
            } catch (error) {
                showToast(`Failed to flood database: ${error.message}`);
                displayMessage(`Failed to flood database: ${error.message}`);
                console.error('Flood Database Error:', error);
            } finally {
                setLoading(buttons.floodDatabase, false);
            }
        }

        async function corruptData() {
            if (!database) {
                showToast('Please apply Firebase URL and path first!');
                return;
            }
            setLoading(buttons.corruptData, true);
            displayMessage(`Corrupting database data recursively at path ${currentPath}...`);
            try {
                const snapshot = await database.ref(currentPath).once('value');
                const data = snapshot.val();
                if (!data) {
                    showToast('No data found to corrupt.');
                    displayMessage(`No data found at path ${currentPath} to corrupt.`);
                    setLoading(buttons.corruptData, false);
                    return;
                }
                const updates = {};
                function processNode(node, parentPath) {
                    if (!node || typeof node !== 'object') return;
                    Object.keys(node).forEach(key => {
                        const fullPath = parentPath ? `${parentPath}/${key}` : key;
                        const rand = Math.random();
                        if (rand < 0.3) {
                            updates[fullPath] = null;
                        } else if (rand < 0.6) {
                            updates[fullPath] = `CORRUPTED_${Math.random().toString(36).substring(2)}`;
                        } else {
                            updates[fullPath] = Math.random() * 1000;
                        }
                        if (typeof node[key] === 'object' && node[key] !== null && !Array.isArray(node[key])) {
                            processNode(node[key], fullPath);
                        }
                    });
                }
                processNode(data, currentPath === '/' ? '' : currentPath);
                await database.ref().update(updates);
                showToast('Successfully corrupted data recursively.');
                displayMessage(`Successfully corrupted data recursively at path ${currentPath}.`);
            } catch (error) {
                showToast(`Failed to corrupt data: ${error.message}`);
                displayMessage(`Failed to corrupt data: ${error.message}`);
                console.error('Corrupt Data Error:', error);
            } finally {
                setLoading(buttons.corruptData, false);
            }
        }

        async function backupDatabase() {
            if (!database) {
                showToast('Please apply Firebase URL and path first!');
                return;
            }
            setLoading(buttons.backupDatabase, true);
            displayMessage(`Backing up database recursively from path ${currentPath}...`);
            try {
                const snapshot = await database.ref(currentPath).once('value');
                const data = snapshot.val();
                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `firebase_backup_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('Database backed up successfully.');
                displayMessage(`Database backed up successfully from path ${currentPath}.`);
            } catch (error) {
                showToast(`Failed to backup database: ${error.message}`);
                displayMessage(`Failed to backup database: ${error.message}`);
                console.error('Backup Database Error:', error);
            } finally {
                setLoading(buttons.backupDatabase, false);
            }
        }

        async function restoreDatabase() {
            if (!database) {
                showToast('Please apply Firebase URL and path first!');
                return;
            }
            setLoading(buttons.restoreDatabase, true);
            const fileInput = document.getElementById('restoreFile');
            if (!fileInput.files.length) {
                showToast('Please select a JSON file to restore.');
                setLoading(buttons.restoreDatabase, false);
                return;
            }
            displayMessage(`Restoring database recursively to path ${currentPath}...`);
            try {
                const file = fileInput.files[0];
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        await database.ref(currentPath).set(data);
                        showToast('Database restored successfully.');
                        displayMessage(`Database restored successfully to path ${currentPath}.`);
                    } catch (error) {
                        showToast(`Failed to restore database: ${error.message}`);
                        displayMessage(`Failed to restore database: ${error.message}`);
                        console.error('Restore Database Error:', error);
                    } finally {
                        setLoading(buttons.restoreDatabase, false);
                        fileInput.value = '';
                    }
                };
                reader.readAsText(file);
            } catch (error) {
                showToast(`Failed to restore database: ${error.message}`);
                displayMessage(`Failed to restore database: ${error.message}`);
                console.error('Restore Database Error:', error);
                setLoading(buttons.restoreDatabase, false);
            }
        }

        async function analyzeDatabase() {
            if (!database) {
                showToast('Please apply Firebase URL and path first!');
                return;
            }
            setLoading(buttons.analyzeDatabase, true);
            displayMessage(`Analyzing database recursively at path ${currentPath}...`);
            try {
                const snapshot = await database.ref(currentPath).once('value');
                const data = snapshot.val();
                if (!data) {
                    showToast('No data found to analyze.');
                    displayMessage(`No data found at path ${currentPath} to analyze.`);
                    setLoading(buttons.analyzeDatabase, false);
                    return;
                }
                let totalItems = 0;
                const types = { folder: 0, boolean: 0, string: 0, number: 0, other: 0 };
                function processNode(node) {
                    if (!node || typeof node !== 'object') return;
                    Object.values(node).forEach(item => {
                        totalItems++;
                        if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
                            if (item.name) types.folder++;
                            processNode(item);
                        } else if (typeof item === 'boolean') {
                            types.boolean++;
                        } else if (typeof item === 'string') {
                            types.string++;
                        } else if (typeof item === 'number') {
                            types.number++;
                        } else {
                            types.other++;
                        }
                    });
                }
                processNode(data);
                const analysis = `Database Analysis at ${currentPath}:\nTotal Items: ${totalItems}\nFolders: ${types.folder}\nBooleans: ${types.boolean}\nStrings: ${types.string}\nNumbers: ${types.number}\nOther: ${types.other}`;
                showToast('Database analyzed successfully.');
                displayMessage(analysis);
            } catch (error) {
                showToast(`Failed to analyze database: ${error.message}`);
                displayMessage(`Failed to analyze database: ${error.message}`);
                console.error('Analyze Database Error:', error);
            } finally {
                setLoading(buttons.analyzeDatabase, false);
            }
        }

        displayMessage('Firebase Hamz Tool ready.');
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93aacbff0a64bd59',t:'MTc0NjM5MTA1NS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
